/**
 * Cloud Storage Repository
 * 雲端儲存資料存取層
 *
 * Handles interaction with Supabase Storage for file operations.
 */

import { Injectable, inject, signal } from '@angular/core';
import { LoggerService } from '@core';
import { SupabaseService } from '@core/services/supabase.service';

import type { CloudFile, CloudBackup, CloudUploadRequest, CloudBackupRequest } from '../models';

/**
 * Cloud Repository
 *
 * Provides data access for cloud storage operations using Supabase Storage.
 */
@Injectable({ providedIn: 'root' })
export class CloudRepository {
  private readonly supabase = inject(SupabaseService);
  private readonly logger = inject(LoggerService);

  // State
  readonly files = signal<CloudFile[]>([]);
  readonly backups = signal<CloudBackup[]>([]);
  readonly loading = signal(false);
  readonly error = signal<string | null>(null);

  /**
   * Get storage bucket name for blueprint
   */
  private getBucketName(blueprintId: string): string {
    return `blueprint-${blueprintId}-files`;
  }

  /**
   * Upload file to cloud storage
   */
  async uploadFile(blueprintId: string, request: CloudUploadRequest): Promise<CloudFile> {
    this.loading.set(true);
    this.error.set(null);

    try {
      const bucket = this.getBucketName(blueprintId);
      const filePath = request.path || `${Date.now()}-${request.file.name}`;

      // Upload to Supabase Storage
      const { data, error } = await this.supabase.client.storage.from(bucket).upload(filePath, request.file, {
        cacheControl: '3600',
        upsert: request.options?.overwrite ?? false
      });

      if (error) {
        throw error;
      }

      // Get public URL
      const { data: urlData } = this.supabase.client.storage.from(bucket).getPublicUrl(data.path);

      // Create file record
      const file: CloudFile = {
        id: crypto.randomUUID(),
        blueprintId,
        name: request.file.name,
        path: data.path,
        size: request.file.size,
        mimeType: request.file.type,
        extension: request.file.name.split('.').pop() || '',
        url: urlData.publicUrl,
        publicUrl: request.isPublic ? urlData.publicUrl : undefined,
        status: 'synced',
        uploadedBy: 'current-user', // TODO: Get from auth context
        uploadedAt: new Date(),
        updatedAt: new Date(),
        metadata: request.metadata,
        bucket,
        isPublic: request.isPublic ?? false
      };

      // Store file metadata in database
      const { error: dbError } = await this.supabase.client.from('cloud_files').insert({
        id: file.id,
        blueprint_id: file.blueprintId,
        name: file.name,
        path: file.path,
        size: file.size,
        mime_type: file.mimeType,
        extension: file.extension,
        url: file.url,
        public_url: file.publicUrl,
        status: file.status,
        uploaded_by: file.uploadedBy,
        uploaded_at: file.uploadedAt.toISOString(),
        updated_at: file.updatedAt.toISOString(),
        metadata: file.metadata,
        bucket: file.bucket,
        is_public: file.isPublic
      });

      if (dbError) {
        this.logger.warn('[CloudRepository]', 'Failed to store file metadata', dbError);
      }

      // Update local state
      this.files.update(files => [...files, file]);

      this.logger.info('[CloudRepository]', `File uploaded: ${file.name}`);
      return file;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Upload failed';
      this.error.set(errorMessage);
      this.logger.error('[CloudRepository]', 'Upload failed', error as Error);
      throw error;
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * Download file from cloud storage
   */
  async downloadFile(blueprintId: string, fileId: string): Promise<Blob> {
    this.loading.set(true);
    this.error.set(null);

    try {
      // Get file metadata
      const file = this.files().find(f => f.id === fileId);
      if (!file) {
        throw new Error(`File not found: ${fileId}`);
      }

      const bucket = this.getBucketName(blueprintId);

      // Download from Supabase Storage
      const { data, error } = await this.supabase.client.storage.from(bucket).download(file.path);

      if (error) {
        throw error;
      }

      this.logger.info('[CloudRepository]', `File downloaded: ${file.name}`);
      return data;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Download failed';
      this.error.set(errorMessage);
      this.logger.error('[CloudRepository]', 'Download failed', error as Error);
      throw error;
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * Delete file from cloud storage
   */
  async deleteFile(blueprintId: string, fileId: string): Promise<void> {
    this.loading.set(true);
    this.error.set(null);

    try {
      // Get file metadata
      const file = this.files().find(f => f.id === fileId);
      if (!file) {
        throw new Error(`File not found: ${fileId}`);
      }

      const bucket = this.getBucketName(blueprintId);

      // Delete from Supabase Storage
      const { error } = await this.supabase.client.storage.from(bucket).remove([file.path]);

      if (error) {
        throw error;
      }

      // Delete metadata from database
      await this.supabase.client.from('cloud_files').delete().eq('id', fileId);

      // Update local state
      this.files.update(files => files.filter(f => f.id !== fileId));

      this.logger.info('[CloudRepository]', `File deleted: ${file.name}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Delete failed';
      this.error.set(errorMessage);
      this.logger.error('[CloudRepository]', 'Delete failed', error as Error);
      throw error;
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * List files for blueprint
   */
  async listFiles(blueprintId: string): Promise<CloudFile[]> {
    this.loading.set(true);
    this.error.set(null);

    try {
      // Query database for file metadata
      const { data, error } = await this.supabase.client
        .from('cloud_files')
        .select('*')
        .eq('blueprint_id', blueprintId)
        .order('uploaded_at', { ascending: false });

      if (error) {
        throw error;
      }

      // Map to CloudFile interface
      const files: CloudFile[] = (data || []).map(row => ({
        id: row.id,
        blueprintId: row.blueprint_id,
        name: row.name,
        path: row.path,
        size: row.size,
        mimeType: row.mime_type,
        extension: row.extension,
        url: row.url,
        publicUrl: row.public_url,
        status: row.status,
        uploadedBy: row.uploaded_by,
        uploadedAt: new Date(row.uploaded_at),
        updatedAt: new Date(row.updated_at),
        metadata: row.metadata,
        bucket: row.bucket,
        isPublic: row.is_public
      }));

      // Update local state
      this.files.set(files);

      this.logger.info('[CloudRepository]', `Loaded ${files.length} files`);
      return files;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'List files failed';
      this.error.set(errorMessage);
      this.logger.error('[CloudRepository]', 'List files failed', error as Error);
      throw error;
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * Create backup
   */
  async createBackup(blueprintId: string, request: CloudBackupRequest): Promise<CloudBackup> {
    this.loading.set(true);
    this.error.set(null);

    try {
      // TODO: Implement actual backup creation
      // For now, create a backup record
      const backup: CloudBackup = {
        id: crypto.randomUUID(),
        blueprintId,
        name: request.name,
        description: request.description,
        type: 'manual',
        status: 'ready',
        size: 0, // TODO: Calculate actual size
        fileCount: request.fileIds?.length || 0,
        path: `backups/${blueprintId}/${Date.now()}-${request.name}.zip`,
        createdAt: new Date(),
        createdBy: 'current-user', // TODO: Get from auth context
        isEncrypted: request.options?.encrypt ?? false,
        metadata: {
          includedFiles: request.fileIds,
          version: '1.0',
          custom: {}
        }
      };

      // Store in database
      await this.supabase.client.from('cloud_backups').insert({
        id: backup.id,
        blueprint_id: backup.blueprintId,
        name: backup.name,
        description: backup.description,
        type: backup.type,
        status: backup.status,
        size: backup.size,
        file_count: backup.fileCount,
        path: backup.path,
        created_at: backup.createdAt.toISOString(),
        created_by: backup.createdBy,
        is_encrypted: backup.isEncrypted,
        metadata: backup.metadata
      });

      // Update local state
      this.backups.update(backups => [...backups, backup]);

      this.logger.info('[CloudRepository]', `Backup created: ${backup.name}`);
      return backup;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Create backup failed';
      this.error.set(errorMessage);
      this.logger.error('[CloudRepository]', 'Create backup failed', error as Error);
      throw error;
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * List backups for blueprint
   */
  async listBackups(blueprintId: string): Promise<CloudBackup[]> {
    this.loading.set(true);
    this.error.set(null);

    try {
      const { data, error } = await this.supabase.client
        .from('cloud_backups')
        .select('*')
        .eq('blueprint_id', blueprintId)
        .order('created_at', { ascending: false });

      if (error) {
        throw error;
      }

      const backups: CloudBackup[] = (data || []).map(row => ({
        id: row.id,
        blueprintId: row.blueprint_id,
        name: row.name,
        description: row.description,
        type: row.type,
        status: row.status,
        size: row.size,
        fileCount: row.file_count,
        path: row.path,
        createdAt: new Date(row.created_at),
        createdBy: row.created_by,
        isEncrypted: row.is_encrypted,
        metadata: row.metadata
      }));

      this.backups.set(backups);
      this.logger.info('[CloudRepository]', `Loaded ${backups.length} backups`);
      return backups;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'List backups failed';
      this.error.set(errorMessage);
      this.logger.error('[CloudRepository]', 'List backups failed', error as Error);
      throw error;
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * Clear state
   */
  clearState(): void {
    this.files.set([]);
    this.backups.set([]);
    this.error.set(null);
  }
}
