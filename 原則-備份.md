🔹 多租戶
🔹 可擴充
🔹 權限安全
🔹 未來能長期演進

用戶 (User)
組織 (Organization)
團隊 (Team) - 組織內
夥伴 (Partner) - 組織外
藍圖 (Blueprint)

藍圖只做一件事：
它有一個 Owner，而 Owner 可以是不同型別

✅ Team 與 Partner 都是「組織的子帳戶（Sub-Account）」
❌ 但它們不是「同一種子帳戶」
Team = 組織內部子帳戶（Internal Sub-Account）
Partner = 組織外部關係子帳戶（External / Federated Sub-Account）

成員部分:
Owner = User
→ Members: User / Collaborators (users only)

Owner = Organization
→ Members: Organization Members / Teams / Partners

Task assignment is scoped to blueprint membership.
A task may only be assigned to users, teams, or partners that are valid members of the blueprint,
and the allowed assignee types are determined by the blueprint’s owner.

一、身份（Identity）與角色（Role）必須嚴格解耦

原則 1：身份 ≠ 權限 ≠ 行為

User / Organization / Team / Partner
👉 只代表「誰」

Role / Permission
👉 代表「能做什麼」

Action / Policy
👉 代表「在什麼條件下能做」


📌 Blueprint 不應 hardcode 任何角色語意

❌ Team 就一定可以指派任務
❌ Partner 一定不能看財務

而是：

Blueprint Owner 決定：
- 哪些 Member Type 可存在
- 哪些 Role 可被賦予
- 哪些 Role 可執行哪些 Action

> 🔑 這是避免「Partner 特例地獄」的關鍵


二、Blueprint 是「權限邊界」不是資料邊界

原則 2：Blueprint = Authorization Boundary

Blueprint 只做三件事：

1. 定義「誰是成員」


2. 定義「成員能做什麼」


3. 限制「行為只能在成員集合內發生」



但 Blueprint 不應：

強制資料儲存方式

綁定某個 domain schema

知道任務 / 財務 / 文件的內部結構


📌 所有 domain 都必須做到：

Domain Data
→ 只知道 blueprint_id
→ 不知道 owner 是誰

三、Owner Type 必須是「策略」而不是「分支判斷」

原則 3：Owner 是 Policy Source，不是 if-else

你已經定義得很好：

Blueprint has exactly ONE owner
Owner ∈ {User, Organization}

補一個關鍵原則：

> ❌ 不要寫：



if (owner.type === 'organization') { ... }

> ✅ 而是：



ownerPolicy.canAssignTo(memberType)
ownerPolicy.canInvite(memberType)
ownerPolicy.allowedAssigneeTypes

📌 這樣未來你要加：

AI Agent Owner

DAO Owner

Smart Contract Owner


Blueprint 不用改結構


四、Membership 是「關係模型」，不是 Entity 屬性

原則 4：Membership 永遠是獨立模型

你現在其實已經在用這個概念了，但要明說：

BlueprintMember
- blueprint_id
- member_type (user | team | partner)
- member_id
- role
- status

禁止：

team.blueprints[]
partner.blueprints[]

原因只有一個：

> 🔥 一個成員，在不同 Blueprint 裡，權限永遠不同


五、Task Assignment ≠ Ownership ≠ Responsibility

原則 5：任務指派不等於責任歸屬

即使你允許：

指派給 Team

指派給 Partner


也必須保證：

最終執行人永遠是 User

行為審計永遠回到 User


📌 建議結構：

Task
- assigned_to (team / partner / user)
- executor (user, nullable)
- accountable (user or organization)

這能保證：

Partner 是外包，不是黑盒

Team 是集合，不是幽靈


六、跨 Blueprint 行為必須是「顯式授權」

原則 6：Blueprint 不自動信任 Blueprint

禁止：

同一個 Organization 的 Blueprint 可以互相存取

所有跨 Blueprint 行為都必須：

建立 Link / Grant / Contract

有 scope

可撤銷

可審計


📌 這對 Partner 特別重要（法律 & 合約）


---

七、審計（Audit）是一級公民

原則 7：任何跨帳戶行為必須可追溯

只要牽涉到：

Partner

Team 代表行為

組織資源


就必須記錄：

who (user)
acting_as (team / partner / org)
in_blueprint
did_what
when

沒有這個，後期一定會炸（真的）


---

八、Blueprint 是「容器」，不是「流程」

原則 8：流程屬於 Engine，不屬於 Blueprint

Blueprint 不應該：

hardcode workflow

綁定某一種 task flow

內建狀態機邏輯


它只提供：

Context
Membership
Policy Surface

Workflow / Automation / State Machine
👉 全部在 Engine 層

（你前面 Blueprint + Automation Engine 的想法是對的）


---

九、刪除永遠是「狀態」，不是「消失」

原則 9：永不硬刪 Owner / Member

特別是 Partner：

歷史任務

合約

責任歸屬


都不能消失

status = suspended | revoked | archived

Blueprint 歷史必須可回放


---

十、Blueprint 是「最小治理單位」

原則 10：所有治理行為必須可下沉到 Blueprint

包括：

成員管理

權限調整

Partner 存取

任務範圍


禁止：

只能在 Organization 全域設定

否則 Blueprint 就不是真正的邏輯容器


---

最後一句總結（很重要）

> Blueprint 不是「功能模組」
Blueprint 是「信任與權限的最小閉包」

