可以的!Firebase Functions 可以直接使用 Google Cloud Document AI。由於 Firebase 專案本身就是 Google Cloud 專案,您可以直接使用相同的專案 ID 和認證。

以下是完整的實作方案:

## 1. 安裝依賴套件

```bash
cd functions
yarn add @google-cloud/documentai @google-cloud/storage
```

## 2. 啟用 Document AI API

在 Google Cloud Console 中啟用 Document AI API:
```
https://console.cloud.google.com/apis/library/documentai.googleapis.com
```

## 3. 創建 Document AI Processor

前往 Document AI Console 創建處理器:
```
https://console.cloud.google.com/ai/document-ai/processors
```

選擇您需要的處理器類型(例如:Form Parser、OCR Processor 等)

## 4. Functions 實作

**functions/src/document-processor.ts**

```typescript
import * as functions from 'firebase-functions';
import { DocumentProcessorServiceClient } from '@google-cloud/documentai';
import { Storage } from '@google-cloud/storage';
import * as admin from 'firebase-admin';

// 初始化 Firebase Admin
if (!admin.apps.length) {
  admin.initializeApp();
}

const storage = new Storage();
const client = new DocumentProcessorServiceClient();

// 配置參數
const projectId = process.env.GCLOUD_PROJECT || 'your-project-id';
const location = 'us'; // 或 'eu', 'asia-southeast1' 等
const processorId = 'YOUR_PROCESSOR_ID'; // 從 Document AI Console 獲取

interface ProcessDocumentRequest {
  bucketName: string;
  fileName: string;
  outputPath?: string;
}

/**
 * HTTP Trigger: 處理文件並將結果存入 Storage
 */
export const processDocument = functions
  .region('asia-east1') // 根據需求調整區域
  .https.onCall(async (data: ProcessDocumentRequest, context) => {
    // 驗證使用者身份
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        '必須登入才能使用此功能'
      );
    }

    const { bucketName, fileName, outputPath } = data;

    try {
      // 1. 從 Storage 讀取文件
      const bucket = storage.bucket(bucketName);
      const file = bucket.file(fileName);
      const [fileBuffer] = await file.download();

      // 2. 準備 Document AI 請求
      const name = `projects/${projectId}/locations/${location}/processors/${processorId}`;
      
      const request = {
        name,
        rawDocument: {
          content: fileBuffer.toString('base64'),
          mimeType: getMimeType(fileName),
        },
      };

      // 3. 呼叫 Document AI 處理文件
      const [result] = await client.processDocument(request);
      const { document } = result;

      if (!document) {
        throw new Error('文件處理失敗');
      }

      // 4. 提取結構化數據
      const extractedData = extractDocumentData(document);

      // 5. 儲存 JSON 到 Storage
      const jsonFileName = outputPath || `processed/${fileName}.json`;
      const jsonFile = bucket.file(jsonFileName);
      
      await jsonFile.save(JSON.stringify(extractedData, null, 2), {
        contentType: 'application/json',
        metadata: {
          originalFile: fileName,
          processedAt: new Date().toISOString(),
          userId: context.auth.uid,
        },
      });

      // 6. 可選:將結果也存入 Firestore
      await admin.firestore().collection('processedDocuments').add({
        userId: context.auth.uid,
        originalFile: fileName,
        jsonFile: jsonFileName,
        extractedData,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        success: true,
        jsonPath: jsonFileName,
        text: document.text,
        pageCount: document.pages?.length || 0,
      };

    } catch (error) {
      console.error('文件處理錯誤:', error);
      throw new functions.https.HttpsError(
        'internal',
        '文件處理失敗',
        error
      );
    }
  });

/**
 * Storage Trigger: 當文件上傳時自動處理
 */
export const onDocumentUpload = functions
  .region('asia-east1')
  .storage.object()
  .onFinalize(async (object) => {
    const filePath = object.name;
    const bucketName = object.bucket;

    // 只處理特定目錄的文件
    if (!filePath?.startsWith('documents/')) {
      return null;
    }

    // 避免處理已處理的 JSON 文件
    if (filePath.endsWith('.json')) {
      return null;
    }

    try {
      const bucket = storage.bucket(bucketName);
      const file = bucket.file(filePath);
      const [fileBuffer] = await file.download();

      // 處理文件
      const name = `projects/${projectId}/locations/${location}/processors/${processorId}`;
      
      const request = {
        name,
        rawDocument: {
          content: fileBuffer.toString('base64'),
          mimeType: object.contentType || 'application/pdf',
        },
      };

      const [result] = await client.processDocument(request);
      const { document } = result;

      if (!document) {
        console.error('文件處理失敗:', filePath);
        return null;
      }

      const extractedData = extractDocumentData(document);

      // 儲存到 processed 目錄
      const jsonPath = `processed/${filePath}.json`;
      const jsonFile = bucket.file(jsonPath);
      
      await jsonFile.save(JSON.stringify(extractedData, null, 2), {
        contentType: 'application/json',
        metadata: {
          originalFile: filePath,
          processedAt: new Date().toISOString(),
        },
      });

      console.log(`文件處理完成: ${jsonPath}`);
      return { success: true, jsonPath };

    } catch (error) {
      console.error('自動處理文件失敗:', error);
      return null;
    }
  });

/**
 * 提取文件結構化數據
 */
function extractDocumentData(document: any) {
  const data: any = {
    text: document.text,
    pages: [],
    entities: [],
    tables: [],
  };

  // 提取頁面資訊
  if (document.pages) {
    data.pages = document.pages.map((page: any, index: number) => ({
      pageNumber: index + 1,
      width: page.dimension?.width,
      height: page.dimension?.height,
      blocks: page.blocks?.length || 0,
      paragraphs: page.paragraphs?.length || 0,
      lines: page.lines?.length || 0,
      tokens: page.tokens?.length || 0,
    }));
  }

  // 提取實體(表單欄位)
  if (document.entities) {
    data.entities = document.entities.map((entity: any) => ({
      type: entity.type,
      mentionText: entity.mentionText,
      confidence: entity.confidence,
      normalizedValue: entity.normalizedValue,
      properties: entity.properties?.map((prop: any) => ({
        type: prop.type,
        mentionText: prop.mentionText,
        confidence: prop.confidence,
      })),
    }));
  }

  // 提取表格
  if (document.pages) {
    document.pages.forEach((page: any, pageIndex: number) => {
      if (page.tables) {
        page.tables.forEach((table: any, tableIndex: number) => {
          const tableData: any = {
            pageNumber: pageIndex + 1,
            tableIndex: tableIndex + 1,
            rows: [],
          };

          if (table.headerRows) {
            tableData.headers = extractTableRows(table.headerRows, document.text);
          }

          if (table.bodyRows) {
            tableData.rows = extractTableRows(table.bodyRows, document.text);
          }

          data.tables.push(tableData);
        });
      }
    });
  }

  return data;
}

/**
 * 提取表格行數據
 */
function extractTableRows(rows: any[], fullText: string) {
  return rows.map((row: any) => {
    return row.cells?.map((cell: any) => {
      return getText(cell.layout?.textAnchor, fullText);
    }) || [];
  });
}

/**
 * 從 textAnchor 提取文字
 */
function getText(textAnchor: any, fullText: string): string {
  if (!textAnchor?.textSegments) {
    return '';
  }

  let text = '';
  textAnchor.textSegments.forEach((segment: any) => {
    const startIndex = parseInt(segment.startIndex || 0);
    const endIndex = parseInt(segment.endIndex || 0);
    text += fullText.substring(startIndex, endIndex);
  });

  return text.trim();
}

/**
 * 根據檔名判斷 MIME Type
 */
function getMimeType(fileName: string): string {
  const ext = fileName.split('.').pop()?.toLowerCase();
  
  const mimeTypes: Record<string, string> = {
    'pdf': 'application/pdf',
    'jpg': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'png': 'image/png',
    'gif': 'image/gif',
    'tiff': 'image/tiff',
    'tif': 'image/tiff',
    'bmp': 'image/bmp',
  };

  return mimeTypes[ext || ''] || 'application/pdf';
}
```

## 5. Angular 前端呼叫

**src/app/services/document.service.ts**

```typescript
import { Injectable, inject } from '@angular/core';
import { Functions, httpsCallable } from '@angular/fire/functions';
import { Storage, ref, uploadBytes, getDownloadURL } from '@angular/fire/storage';
import { Observable, from, switchMap } from 'rxjs';

interface ProcessResult {
  success: boolean;
  jsonPath: string;
  text: string;
  pageCount: number;
}

@Injectable({
  providedIn: 'root'
})
export class DocumentService {
  private readonly functions = inject(Functions);
  private readonly storage = inject(Storage);

  /**
   * 上傳並處理文件
   */
  uploadAndProcess(file: File): Observable<ProcessResult> {
    const timestamp = Date.now();
    const fileName = `documents/${timestamp}_${file.name}`;
    const storageRef = ref(this.storage, fileName);

    return from(uploadBytes(storageRef, file)).pipe(
      switchMap(() => {
        const processDoc = httpsCallable<any, ProcessResult>(
          this.functions,
          'processDocument'
        );

        return from(processDoc({
          bucketName: 'your-project-id.appspot.com', // 替換為您的 bucket
          fileName: fileName,
        }));
      })
    );
  }

  /**
   * 獲取處理後的 JSON
   */
  getProcessedJson(jsonPath: string): Observable<any> {
    const jsonRef = ref(this.storage, jsonPath);
    return from(getDownloadURL(jsonRef)).pipe(
      switchMap(url => from(fetch(url).then(res => res.json())))
    );
  }
}
```

## 6. 環境變數設定

**functions/.env** (本地開發)

```bash
GCLOUD_PROJECT=your-project-id
DOCUMENT_AI_PROCESSOR_ID=your-processor-id
```

## 7. 部署

```bash
cd functions
yarn build
firebase deploy --only functions
```

## 重點注意事項

1. **Processor ID**: 記得替換 `YOUR_PROCESSOR_ID` 為實際的處理器 ID
2. **區域設定**: Document AI 需要與 Functions 在相容的區域
3. **權限**: Firebase Functions 預設有專案的完整權限,無需額外設定
4. **計費**: Document AI 有免費額度,超過需付費
5. **檔案大小限制**: 注意 Functions 的記憶體和超時限制

需要我協助設定特定的 Processor 類型或調整解析邏輯嗎?